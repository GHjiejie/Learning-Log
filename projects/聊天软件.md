### 1、如何去去设计数据库

就单纯的从实现聊天的功能来看的话，我的项目只使用了3个表，一个是记录会话的列表，一个是记录用户数据的列表，一个是记录聊天消息的列表

##### `conversion.model.js`

```javascript

const conversationSchema = new Schema(
  {
    // 会话类型
    type: {
      type: String,
      enum: ["private", "group"],
      required: true,   
    },

    // 会话成员       
    members: [
      {
        type: Schema.Types.ObjectId,
        ref: "User",
        required: true,
      },
    ],

    // 会话名称 (可选, 仅群聊需要)
    chatName: {
      type: String,
      trim: true,
    },

    // 最后一条消息 (可选, 用于优化会话列表展示)
    lastMessage: {
      _id: false, // 嵌套文档不需要 _id
      content: String,
      senderId: { type: Schema.Types.ObjectId, ref: "User" },
      createdAt: Date,
    },
  },
  { timestamps: true }
);

// 创建索引
conversationSchema.index({ members: 1 }, { background: true }); // 优化用户会话查询
```

##### `user.model.js`

```javascript
const userSchema = new Schema(
  {
    username: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    avatar: {
      type: String,
      default: "http://localhost:3000/uploads/default.png",
    },
     //记录用户的状态
    status: {
      type: String,
      enum: ["online", "offline", "busy"],
      default: "offline",
    },
    phone: { type: String, default: "18196576670" },
      //用户的好友列表
    friends: [{ type: Schema.Types.ObjectId, ref: "User" }],
      //用户收到的好友申请
    friendRequests: [friendRequestSchema],
      //用户发送的好友申请列表
    sentFriendRequests: [friendRequestSchema],
    blockedUsers: [{ type: Schema.Types.ObjectId, ref: "User" }],
  },
  { timestamps: true }
);
```

##### `message.model.js`

```javascript

const messageSchema = new Schema(
  {
    // 所属会话 ID
    conversationId: {
      type: Schema.Types.ObjectId,
      ref: "Conversation",
      required: true,
    },

    // 消息内容
    content: {
      type: new Schema(
        {
          // 发送者 ID
          senderId: {
            type: Schema.Types.ObjectId,
            ref: "User",
            required: true,
          },

          // 消息文本内容
          text: {
            type: String,
          },

          // 消息类型
          type: {
            type: String,
            enum: ["text", "image", "file"], // 可以根据需要添加更多类型
            required: true,
          },

          // 文件或图片链接 (可选, 仅当 type 为 'image' 或 'file' 时需要)
          mediaUrl: {
            type: String,
          },
          // 文件类型 (可选, 仅当 type 为 'file' 时需要)
          fileType: {
            type: String,
          },

          // 文件名 (可选, 仅当 type 为 'file' 时需要)
          fileName: {
            type: String,
          },

          // 发送时间
          sentAt: {
            type: Date,
            default: Date.now,
            required: true,
          },
        },
        { _id: false } // 禁用嵌套文档的 _id
      ),
      required: true,
    },
  },
  { timestamps: true }
);
```



### 2、如何去设计用户聊天的消息

在处理聊天消息时，我们通常会为每条新消息创建一个新的文档，而不是更新现有的会话文档，主要有以下几个原因：

##### **1. 数据一致性和可追溯性：**

*   **独立性:** 每条消息都是一个独立的事件，拥有自己的发送时间、发送者和内容。将其存储为独立的文档可以更好地维护数据的完整性和一致性。
*   **历史记录:**  创建新文档可以方便地追踪每条消息的发送历史，包括编辑历史（如果需要）。如果将所有消息都存储在会话文档中，那么更新消息时可能会丢失之前的版本。
*   **查询效率:**  查询特定时间段内的消息，或者查询某个用户发送的所有消息，都会更加高效。

##### **2. 性能和并发性：**

*   **并发控制:**  多个用户可能同时发送消息。如果将所有消息存储在同一个会话文档中，就会存在并发更新的问题，需要复杂的锁机制来保证数据一致性。而创建新文档可以避免这种问题，因为每个用户都在操作不同的文档。
*   **数据量:**  随着时间的推移，会话中的消息数量会不断增加。如果将所有消息都存储在同一个文档中，会导致文档体积越来越大，影响查询和更新性能。而创建新文档可以将数据分散存储，提高数据库性能。

**3. 可扩展性：**

*   **消息类型:**  聊天应用通常支持多种消息类型，例如文本、图片、文件等。将每条消息存储为独立的文档，可以更方便地扩展消息类型，只需添加新的字段即可。
*   **消息状态:**  消息可能会有不同的状态，例如已发送、已送达、已读等。将每条消息存储为独立的文档，可以更方便地管理消息状态，只需更新对应文档的字段即可。

**总而言之，为每条新消息创建一个新文档是更合理、更可扩展的设计方案，可以带来更好的数据一致性、性能和可维护性。**

### 3、在 `vue.config.js`里面配置了别名之后，我们 `Ctrl`+鼠标右键无法实现跳转怎么解决？

其实网络上已经给出了解决方案 [vue中使用别名不能提示路径](https://juejin.cn/post/7159469184823492645)，但是我们还是需要自己再说明一下



