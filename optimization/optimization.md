### 1.在设计按钮的时候要为按钮添加可访问名称

这个主要是为了使用屏幕阅读器的用户

具体实现有两种方式，使用 `aria-label`与 `aria-labelledby`

他们的使用区别于应用场景如下：

- **使用 `aria-label`  的场景:**
    - 按钮或链接本身没有或只有很少的文本内容。
    - 按钮或链接的功能是**独立的**，不会影响到页面上其他元素的状态或数据。
    - 按钮的 accessible name  是**固定的**，不会随着页面状态或数据的变化而改变。

- **使用 `aria-labelledby`  的场景:**
    - 按钮或链接的 accessible name  需要**参考页面上其他元素的内容**，例如显示数量、状态或其他动态信息。
    - 按钮或链接的功能会**影响到页面上其他元素的状态或数据**，需要让屏幕阅读器用户感知到这些变化。
    - 按钮的 accessible name  是**动态的**，会随着页面状态或数据的变化而改变。

**举例说明：**

- **`aria-label`  示例:**  "提交表单"、 "关闭窗口"、 "播放视频" 等。 
   - 这些按钮的功能相对独立， 不会影响其他数据， 而且按钮的文字描述也是固定的。

- **`aria-labelledby`  示例:**  "购物车 (3)"、 "喜欢 (10)"、 "评论 (5)"  等。
   - 这些按钮的功能会影响到其他数据 (例如购物车中的商品数量、点赞数量),  而且按钮的文字描述需要随着数据的变化而更新。

**总结：**

选择使用 `aria-label` 还是 `aria-labelledby` ，需要根据具体的场景和需求来决定。 最终目标是为屏幕阅读器用户提供清晰、准确、易于理解的网页内容和交互方式。



### 2.对图片的处理

#### 摒弃原来的JPEG与PNG格式的图片，优先使用Webp与AVIF个格式的图片，

**优点如下**：

**1.  更高的压缩率和更小的文件大小：**

- AVIF 和 WebP 使用更先进的压缩算法，可以在保证图片质量的前提下，实现比 JPEG 和 PNG 更高的压缩率，从而生成更小的文件。
- **例如：** 相同质量下， AVIF 文件大小通常比 JPEG 小 50%， 比 PNG 小 70% 以上； WebP 文件大小也比 JPEG 小 25%-34%， 比 PNG 小 26%。

**2. 更高的图片质量：**

- 在相同文件大小下， AVIF 和 WebP 格式的图片通常比 JPEG 和 PNG 格式的图片拥有更高的视觉质量， 更少的失真和 artifacts。

**3. 支持更丰富的功能：**

- AVIF 和 WebP 支持透明度、动画、更广的色域等功能， 而 JPEG 不支持透明度， PNG 在动画和压缩效率方面存在不足。

**4. 更好的用户体验：**

- 更小的图片文件意味着更快的页面加载速度，从而提升用户体验， 降低网站跳出率。
- 更高的图片质量可以提升网站的视觉效果， 增强用户体验。

**5. 节省带宽和存储空间：**

- 对于网站运营者来说， 使用 AVIF 或 WebP 格式的图片可以节省带宽成本和存储空间。

**缺点如下**：0

- **浏览器兼容性：** 目前并非所有浏览器都完全支持 AVIF 和 WebP 格式， 需要根据目标用户的浏览器使用情况进行选择。
- **编码和解码速度：** AVIF 的编码速度相对较慢， WebP 的解码速度也可能比 JPEG 和 PNG 慢。
- **生态系统支持：** JPEG 和 PNG 格式已经存在多年， 生态系统非常完善， 而 AVIF 和 WebP 还比较新， 一些图像编辑软件和网站平台可能还不支持。

#### 图片的延迟加载

- 主要原因是因为如果 `img`标签里面有 `src`属性时，浏览器会直接通过这个链接去加载这个图片，都是现在我们的思路是将 `src`替换成 `data-src`,这样就避免了浏览器的默认事件，我们可以使用官方推荐的框架 [lazysizes](https://github.com/aFarkas/lazysizes)去实现，这个框架易于上手，上面有详细的教程
- 我们也可以使用  [IntersectionObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver) 这个API来监听图片元素在视口的位置来实现对图片的延迟加载

#### 使用图片 CDN 优化图片

#### 压缩图片

- 我一直使用的是 [sharp.js](https://github.com/lovell/sharp) 这个库，当然，还是有很多其他的库可以去使用的，比如官方推荐的[imagemin.js](https://github.com/imagemin/imagemin),webpack默认的对图片的压缩plugin就是这个,

  官方推荐的是将JPEG的图片压缩级别设置为85，暂时就先先按这个来吧

#### 将GIF动画改为视频播放

使用gif的缺点：

1. gif会自动播放
2. 他会连续播放
3. 他们会保持沉默

都是视频可以定制上面的行为，那么如何将`gif`转换为视频呢？可以使用 [FFmpeg](https://www.ffmpeg.org/)

###  3.缩减网络载荷并对其进行压缩

具体原因可以参考 [优化基于文本的资源的编码和传输大小](https://web.dev/articles/optimizing-content-efficiency-optimize-encoding-and-transfer?hl=zh-cn)

 以我在实习时的Hiten大模型为例，本地环境与生产环境的区别是很大的



### 4.使用合适的缓存策略去提供静态资源

可以参考文档 [采用高效的缓存政策提供静态资源](https://developer.chrome.com/docs/lighthouse/performance/uses-long-cache-ttl?hl=zh-cn)，后面可能会涉及到灰度部署



### 5.避免链接关键请求

这个会涉及到**Chrome资源优先级和调度**

下面是GPT给出的回答：

### 6.Chrome 资源优先级和调度

Chrome 浏览器使用一个复杂的系统来确定资源加载的优先级和调度顺序，以优化页面加载性能和用户体验。

#### 资源分类

Chrome 将页面资源分为以下几类，并根据类别分配不同的优先级：

*   **最高优先级:**
    *   **文档 (HTML):**  构建 DOM 树的基石。
    *   **关键子资源:**  阻塞渲染的关键资源，例如 CSS、字体文件等。
*   **高优先级:**
    *   **脚本 (JS):**  可能影响页面渲染和交互。
    *   **图片 (Images):**  首屏可见区域的图片。
    *   **XHR 请求:**  获取重要数据的异步请求。
*   **低优先级:**
    *   **图片 (Images):**  非首屏可见区域的图片 (懒加载)。
    *   **预加载资源:**  未来可能用到的资源。
    *   **跟踪脚本:**  用于分析和监控的脚本。
*   **最低优先级:**
    *   **广告:**  广告资源。
    *   **第三方脚本:**  非关键的第三方脚本。

#### 影响优先级的因素

除了资源类型，以下因素也会影响资源的优先级：

*   **资源大小:**  较小的资源通常优先级更高。
*   **连接类型:**  快速连接 (例如 WiFi) 上的资源优先级更高。
*   **缓存状态:**  已缓存的资源优先级更高。
*   **用户交互:**  与用户交互相关的资源优先级更高。
*   **开发者提示:**  开发者可以使用 `<link rel="preload">` 或 `fetch(..., {priority: "high"})`  等方式提示资源的重要性。

#### 调度策略

Chrome 使用以下策略来调度资源加载：

*   **并行下载:**  同时下载多个资源，但限制并发连接数以避免网络拥塞。
*   **优先级队列:**  根据资源优先级排序，高优先级资源优先下载。
*   **依赖关系:**  如果资源 A 依赖于资源 B，则资源 B 会优先下载。
*   **预加载扫描器:**  预先扫描 HTML 代码，发现需要加载的资源并提前下载。
*   **资源限制:**  限制特定类型资源的并发请求数，例如图片、脚本等。

#### 查看资源优先级

你可以使用 Chrome 开发者工具 (Network 面板) 查看资源的优先级：

1.  打开开发者工具 (F12 或 Ctrl+Shift+I)。
2.  切换到 "Network" 面板。
3.  刷新页面。
4.  在 "Name" 列中找到你想要查看的资源。
5.  查看 "Priority" 列，它会显示资源的优先级 (Highest, High, Medium, Low, Lowest)。

#### 优化建议

为了优化页面加载性能，你可以采取以下措施：

*   **减少关键资源数量:**  合并 CSS 和 JS 文件，减少 HTTP 请求数。
*   **优化资源大小:**  压缩图片、代码等资源，使用 WebP 等现代图片格式。
*   **使用缓存:**  设置合理的缓存策略，减少重复下载。
*   **懒加载非关键资源:**  使用懒加载技术延迟加载非首屏可见区域的图片和视频。
*   **使用 CDN:**  使用内容分发网络 (CDN) 加速资源访问。
*   **使用预加载:**  使用 `<link rel="preload">`  预加载关键资源。
*   **优化脚本执行:**  减少 JavaScript 代码量，避免阻塞渲染。

通过理解 Chrome 的资源优先级和调度机制，并采取相应的优化措施，可以显著提升网站的加载速度和用户体验。



